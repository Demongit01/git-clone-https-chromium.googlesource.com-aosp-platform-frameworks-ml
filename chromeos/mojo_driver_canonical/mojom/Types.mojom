// Copyright 2022 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This is a Mojo representation of the NNAPI HAL CANONICAL API
// (https://chromium.googlesource.com/aosp/platform/frameworks/ml/+/refs/heads/main/common/types/include/nnapi/)

module chromeos.nnapi.canonical.mojom;

[Extensible] enum OperandType {
  FLOAT32 = 0,
  INT32 = 1,
  UINT32 = 2,
  TENSOR_FLOAT32 = 3,
  TENSOR_INT32 = 4,
  TENSOR_QUANT8_ASYMM = 5,
  BOOL = 6,
  TENSOR_QUANT16_SYMM = 7,
  TENSOR_FLOAT16 = 8,
  TENSOR_BOOL8 = 9,
  FLOAT16 = 10,
  TENSOR_QUANT8_SYMM_PER_CHANNEL = 11,
  TENSOR_QUANT16_ASYMM = 12,
  TENSOR_QUANT8_SYMM = 13,
  TENSOR_QUANT8_ASYMM_SIGNED = 14,
  SUBGRAPH = 15,
  OEM = 10000,
  TENSOR_OEM_BYTE = 10001,
};


[Extensible] enum VersionLevel {
  FEATURE_LEVEL_1,
  FEATURE_LEVEL_2,
  FEATURE_LEVEL_3,
  FEATURE_LEVEL_4,
  FEATURE_LEVEL_5,
  FEATURE_LEVEL_6,
  FEATURE_LEVEL_7,
  FEATURE_LEVEL_8,
  FEATURE_LEVEL_EXPERIMENTAL,
};

[Extensible] enum DeviceType {
  UNKNOWN = 0,
  OTHER = 1,
  CPU = 2,
  GPU = 3,
  ACCELERATOR = 4,
};

[Extensible] enum ErrorStatus {
  NONE = 0,
  DEVICE_UNAVAILABLE = 1,
  GENERAL_FAILURE = 2,
  OUTPUT_INSUFFICIENT_SIZE = 3,
  INVALID_ARGUMENT = 4,
  MISSED_DEADLINE_TRANSIENT = 5,
  MISSED_DEADLINE_PERSISTENT = 6,
  RESOURCE_EXHAUSTED_TRANSIENT = 7,
  RESOURCE_EXHAUSTED_PERSISTENT = 8,
  DEAD_OBJECT = 10000,
};

[Extensible] enum ExecutionPreference {
  LOW_POWER = 0,
  FAST_SINGLE_ANSWER = 1,
  SUSTAINED_SPEED = 2,
};

[Extensible] enum Priority {
  LOW,
  MEDIUM,
  HIGH,
};

[Extensible] enum OperandLifeTime {
  TEMPORARY_VARIABLE = 0,
  SUBGRAPH_INPUT = 1,
  SUBGRAPH_OUTPUT = 2,
  CONSTANT_COPY = 3,
  CONSTANT_REFERENCE = 4,
  NO_VALUE = 5,
  SUBGRAPH = 6,
  POINTER = 7,  // hidl/aidl don't support POINTER
};

[Extensible] enum OperationType {
    ADD = 0,
    AVERAGE_POOL_2D = 1,
    CONCATENATION = 2,
    CONV_2D = 3,
    DEPTHWISE_CONV_2D = 4,
    DEPTH_TO_SPACE = 5,
    DEQUANTIZE = 6,
    EMBEDDING_LOOKUP = 7,
    FLOOR = 8,
    FULLY_CONNECTED = 9,
    HASHTABLE_LOOKUP = 10,
    L2_NORMALIZATION = 11,
    L2_POOL_2D = 12,
    LOCAL_RESPONSE_NORMALIZATION = 13,
    LOGISTIC = 14,
    LSH_PROJECTION = 15,
    LSTM = 16,
    MAX_POOL_2D = 17,
    MUL = 18,
    RELU = 19,
    RELU1 = 20,
    RELU6 = 21,
    RESHAPE = 22,
    RESIZE_BILINEAR = 23,
    RNN = 24,
    SOFTMAX = 25,
    SPACE_TO_DEPTH = 26,
    SVDF = 27,
    TANH = 28,
    BATCH_TO_SPACE_ND = 29,
    DIV = 30,
    MEAN = 31,
    PAD = 32,
    SPACE_TO_BATCH_ND = 33,
    SQUEEZE = 34,
    STRIDED_SLICE = 35,
    SUB = 36,
    TRANSPOSE = 37,
    ABS = 38,
    ARGMAX = 39,
    ARGMIN = 40,  // See ARGMAX for naming discussion.
    AXIS_ALIGNED_BBOX_TRANSFORM = 41,
    BIDIRECTIONAL_SEQUENCE_LSTM = 42,
    BIDIRECTIONAL_SEQUENCE_RNN = 43,
    BOX_WITH_NMS_LIMIT = 44,
    CAST = 45,
    CHANNEL_SHUFFLE = 46,
    DETECTION_POSTPROCESSING = 47,
    EQUAL = 48,
    EXP = 49,
    EXPAND_DIMS = 50,
    GATHER = 51,
    GENERATE_PROPOSALS = 52,
    GREATER = 53,
    GREATER_EQUAL = 54,
    GROUPED_CONV_2D = 55,
    HEATMAP_MAX_KEYPOINT = 56,
    INSTANCE_NORMALIZATION = 57,
    LESS = 58,
    LESS_EQUAL = 59,
    LOG = 60,
    LOGICAL_AND = 61,
    LOGICAL_NOT = 62,
    LOGICAL_OR = 63,
    LOG_SOFTMAX = 64,
    MAXIMUM = 65,
    MINIMUM = 66,
    NEG = 67,
    NOT_EQUAL = 68,
    PAD_V2 = 69,
    POW = 70,
    PRELU = 71,
    QUANTIZE = 72,
    QUANTIZED_16BIT_LSTM = 73,
    RANDOM_MULTINOMIAL = 74,
    REDUCE_ALL = 75,
    REDUCE_ANY = 76,
    REDUCE_MAX = 77,
    REDUCE_MIN = 78,
    REDUCE_PROD = 79,
    REDUCE_SUM = 80,
    ROI_ALIGN = 81,
    ROI_POOLING = 82,
    RSQRT = 83,
    SELECT = 84,
    SIN = 85,
    SLICE = 86,
    SPLIT = 87,
    SQRT = 88,
    TILE = 89,
    TOPK_V2 = 90,
    TRANSPOSE_CONV_2D = 91,
    UNIDIRECTIONAL_SEQUENCE_LSTM = 92,
    UNIDIRECTIONAL_SEQUENCE_RNN = 93,
    RESIZE_NEAREST_NEIGHBOR = 94,
    QUANTIZED_LSTM = 95,
    IF = 96,
    WHILE = 97,
    ELU = 98,
    HARD_SWISH = 99,
    FILL = 100,
    RANK = 101,
    BATCH_MATMUL = 102,
    PACK = 103,
    MIRROR_PAD = 104,
    REVERSE = 105,
    OEM_OPERATION = 10000,
};

[Extensible] enum MeasureTiming {
  NO = 0,
  YES = 1,
};

struct GeneralError {
  string message;
  ErrorStatus code;
};

struct PerformanceInfo {
  float execTime;
  float powerUsage;
};

struct OperandPerformance {
  OperandType type;
  PerformanceInfo info;
};

struct OperandPerformanceTable {
  array<OperandPerformance> operandPerformances;
};

struct Capabilities {
  PerformanceInfo relaxedFloat32toFloat16PerformanceScalar;
  PerformanceInfo relaxedFloat32toFloat16PerformanceTensor;
  OperandPerformanceTable operandPerformance;
  PerformanceInfo ifPerformance;
  PerformanceInfo whilePerformance;
};

struct Version {
  VersionLevel level;
  bool runtimeOnlyFeatures = false;
};

struct ExtensionOperandTypeInformation {
  uint16 type;
  bool isTensor;
  uint32 byteSize;
};

struct Extension {
  string name;
  array<ExtensionOperandTypeInformation> operandTypes;
};

struct TimePoint {
  uint64 nanosecondsSinceEpoch;
};

struct NnHandle {
  handle<platform> fd;
};

struct CacheToken {
  array<uint8> token;
};

struct TokenValuePair {
  int32 token;
  array<uint8> value;
};

struct ExtensionNameAndPrefix {
  string name;
  uint16 prefix;
};

struct OperandValues {
  array<uint8> mData;
};

struct SymmPerChannelQuantParams {
    array<float> scales;
    uint32 channelDim;
};

struct Monostate {
};

union ExtraParams {
  Monostate none;
  SymmPerChannelQuantParams channelQuant;
  array<uint8> extension;
};

struct DataLocation {
  // hidl/aidl don't support POINTER
  // std::variant<const void*, void*> pointer;
  uint32 poolIndex;
  uint32 offset;
  uint32 length;
  uint32 padding;
};

struct Operand {
  OperandType type;
  array<uint32> dimensions;
  float scale;
  int32 zeroPoint;
  OperandLifeTime lifetime;
  DataLocation location;
  ExtraParams extraParams;
};

struct Operation {
  OperationType type;
  array<uint32> inputs;
  array<uint32> outputs;
};

struct ModelSubgraph {
  array<Operand> operands;
  array<Operation> operations;
  array<uint32> inputIndexes;
  array<uint32> outputIndexes;
};

struct Ashmem {
  handle<platform> fd;
  int32 size;
};

struct Fd {
  int32 size;
  int32 prot;
  handle<platform> fd;
  int32 offset;
};

struct HardwareBuffer {
  // do not support
};

struct MemoryUnknown {
  array<handle<platform>> fds;
  array<int32> ints;
  int32 size;
  string name;
};

union NnMemory {
  Ashmem ashmemHandle;
  Fd fdHandle;
  HardwareBuffer hardwareBufferHandle;
  MemoryUnknown unknownHandle;
};

struct Model {
  ModelSubgraph main;
  array<ModelSubgraph> referenced;
  OperandValues operandValues;
  array<NnMemory> pools;
  bool relaxComputationFloat32toFloat16;
  array<ExtensionNameAndPrefix> extensionNameToPrefix;
};

struct ExecutionError {
  string message;
  ErrorStatus code;
  array<OutputShape> outputShapes;
};

struct OutputShape {
  array<uint32> dimensions;
  bool isSufficient;
};

struct Timing {
  Duration? timeOnDevice;
  Duration? timeInDriver;
};

struct Duration {
  uint64 nanoseconds;
};

[Extensible] enum RequestArgumentLifeTime {
  POOL = 0,
  NO_VALUE = 1,
  POINTER = 2,
};

struct RequestArgument {
  RequestArgumentLifeTime lifetime;
  DataLocation location;
  array<uint32> dimensions;
};

struct RequestMemoryPool{
  NnMemory memory;
};

struct Request {
  array<RequestArgument> inputs;
  array<RequestArgument> outputs;
  array<RequestMemoryPool> pools;
};

struct SyncFence {
  NnHandle mSyncFence;
};

interface IExecuteFencedInfoCallback {
  [Sync] getExecuteFencedInfo() => (GeneralError status, Timing timingLaunched, Timing timingFenced);
};

// version 5
